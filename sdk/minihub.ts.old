/**
 * MiniHub SDK - Decentralized Job Board on Sui
 * 
 * React SDK for interacting with the MiniHub smart contract
 * Supports both read operations and transaction building
 */

import { SuiClient, SuiObjectData } from '@mysten/sui/client';
import { Transaction } from '@mysten/sui/transactions';

// ============================================================
// TYPES & INTERFACES
// ============================================================

export interface JobData {
  id: string;
  employer: string;
  title: string;
  description: string;
  salary: string | null; // Option<u64> as string or null
  applicationCount: string; // u64 as string
  hiredCandidate: string | null; // Option<address>
  isActive: boolean;
  deadline: string; // u64 timestamp in milliseconds
}

export interface ApplicationData {
  id: string;
  candidate: string;
  jobId: string;
  coverMessage: string;
  timestamp: string; // u64 as string
  cvUrl: string;
}

export interface JobBoardData {
  id: string;
  jobCount: string; // u64 as string
  jobIds: string[];
}

export interface MiniHubConfig {
  packageId: string;
  jobBoardId: string;
  suiClient: SuiClient;
}

// ============================================================
// MINIHUB SDK CLASS
// ============================================================

export class MiniHubSDK {
  private packageId: string;
  private jobBoardId: string;
  private client: SuiClient;

  constructor(config: MiniHubConfig) {
    this.packageId = config.packageId;
    this.jobBoardId = config.jobBoardId;
    this.client = config.suiClient;
  }

  // ============================================================
  // READ FUNCTIONS - Ağdan Okuma Fonksiyonları
  // ============================================================

  /**
   * JobBoard'u oku - Toplam iş sayısını ve ID'leri getir
   * Reads the JobBoard - Get total job count and job IDs
   */
  async getJobBoard(): Promise<JobBoardData> {
    const object = await this.client.getObject({
      id: this.jobBoardId,
      options: { showContent: true },
    });

    if (!object.data?.content || object.data.content.dataType !== 'moveObject') {
      throw new Error('JobBoard not found or invalid');
    }

    const fields = object.data.content.fields as any;
    
    return {
      id: this.jobBoardId,
      jobCount: fields.job_count,
      jobIds: fields.job_ids || [],
    };
  }

  /**
   * Tek bir iş ilanını oku
   * Read a single job posting
   */
  async getJob(jobId: string): Promise<JobData> {
    const object = await this.client.getObject({
      id: jobId,
      options: { showContent: true },
    });

    if (!object.data?.content || object.data.content.dataType !== 'moveObject') {
      throw new Error('Job not found or invalid');
    }

    const fields = object.data.content.fields as any;

    return {
      id: jobId,
      employer: fields.employer,
      title: fields.title,
      description: fields.description,
      salary: fields.salary ? fields.salary : null,
      applicationCount: fields.application_count,
      hiredCandidate: fields.hired_candidate ? fields.hired_candidate : null,
      isActive: fields.is_active,
      deadline: fields.deadline,
    };
  }

  /**
   * Birden fazla iş ilanını toplu oku
   * Read multiple job postings in batch
   */
  async getJobs(jobIds: string[]): Promise<JobData[]> {
    const objects = await this.client.multiGetObjects({
      ids: jobIds,
      options: { showContent: true },
    });

    return objects
      .filter((obj) => obj.data?.content?.dataType === 'moveObject')
      .map((obj) => {
        const fields = (obj.data!.content as any).fields;
        return {
          id: obj.data!.objectId,
          employer: fields.employer,
          title: fields.title,
          description: fields.description,
          salary: fields.salary ? fields.salary : null,
          applicationCount: fields.application_count,
          hiredCandidate: fields.hired_candidate ? fields.hired_candidate : null,
          isActive: fields.is_active,
          deadline: fields.deadline,
        };
      });
  }

  /**
   * Tüm iş ilanlarını getir
   * Get all job postings
   */
  async getAllJobs(): Promise<JobData[]> {
    const jobBoard = await this.getJobBoard();
    return this.getJobs(jobBoard.jobIds);
  }

  /**
   * Aktif iş ilanlarını filtrele
   * Filter active job postings
   */
  async getActiveJobs(): Promise<JobData[]> {
    const allJobs = await this.getAllJobs();
    return allJobs.filter((job) => job.isActive);
  }

  /**
   * Belirli bir işverene ait ilanları getir
   * Get jobs by employer address
   */
  async getJobsByEmployer(employerAddress: string): Promise<JobData[]> {
    const allJobs = await this.getAllJobs();
    return allJobs.filter((job) => job.employer === employerAddress);
  }

  /**
   * Deadline'a göre ilanları filtrele (henüz bitmemiş)
   * Filter jobs by deadline (not yet passed)
   */
  async getJobsBeforeDeadline(): Promise<JobData[]> {
    const allJobs = await this.getAllJobs();
    const now = Date.now();
    return allJobs.filter((job) => parseInt(job.deadline) > now);
  }

  /**
   * Maaşa göre ilanları sırala (yüksekten düşüğe)
   * Sort jobs by salary (high to low)
   */
  async getJobsSortedBySalary(): Promise<JobData[]> {
    const allJobs = await this.getAllJobs();
    return allJobs
      .filter((job) => job.salary !== null)
      .sort((a, b) => parseInt(b.salary!) - parseInt(a.salary!));
  }

  /**
   * Kullanıcının sahip olduğu EmployerCap'leri getir
   * Get EmployerCap objects owned by user
   */
  async getEmployerCapabilities(ownerAddress: string): Promise<string[]> {
    const objects = await this.client.getOwnedObjects({
      owner: ownerAddress,
      filter: {
        StructType: `${this.packageId}::minihub::EmployerCap`,
      },
      options: { showContent: true },
    });

    return objects.data
      .filter((obj) => obj.data?.content?.dataType === 'moveObject')
      .map((obj) => {
        const fields = (obj.data!.content as any).fields;
        return fields.job_id;
      });
  }

  /**
   * Bir işin başvuru sayısını kontrol et
   * Check application count for a job
   */
  async getApplicationCount(jobId: string): Promise<number> {
    const job = await this.getJob(jobId);
    return parseInt(job.applicationCount);
  }

  /**
   * İşin dolu olup olmadığını kontrol et
   * Check if job is filled
   */
  async isJobFilled(jobId: string): Promise<boolean> {
    const job = await this.getJob(jobId);
    return job.hiredCandidate !== null;
  }

  // ============================================================
  // TRANSACTION BUILDERS - Transaction Oluşturucular
  // ============================================================

  /**
   * Yeni iş ilanı yayınla
   * Post a new job
   */
  postJob(params: {
    title: string;
    description: string;
    salary?: number; // optional salary in u64
    deadlineMs: number; // timestamp in milliseconds
  }): Transaction {
    const tx = new Transaction();

    // Option<u64> için salary
    const salaryArg = params.salary
      ? tx.pure.option('u64', params.salary)
      : tx.pure.option('u64', null);

    tx.moveCall({
      target: `${this.packageId}::minihub::post_job`,
      arguments: [
        tx.object(this.jobBoardId), // job_board: &mut JobBoard
        tx.pure.string(params.title), // title: String
        tx.pure.string(params.description), // description: String
        salaryArg, // salary: Option<u64>
        tx.pure.u64(params.deadlineMs), // deadline: u64
      ],
    });

    return tx;
  }

  /**
   * İşe başvur
   * Apply to a job
   */
  applyToJob(params: {
    jobId: string;
    coverMessage: string;
    cvUrl: string;
    clockId?: string; // Sui Clock object ID (default: 0x6)
  }): Transaction {
    const tx = new Transaction();

    tx.moveCall({
      target: `${this.packageId}::minihub::apply_to_job`,
      arguments: [
        tx.object(params.jobId), // job: &mut Job
        tx.pure.string(params.coverMessage), // cover_message: String
        tx.pure.string(params.cvUrl), // cv_url: String
        tx.object(params.clockId || '0x6'), // clock: &Clock
      ],
    });

    return tx;
  }

  /**
   * Adayı işe al
   * Hire a candidate
   */
  hireCandidate(params: {
    jobId: string;
    employerCapId: string;
    candidateAddress: string;
    candidateIndex: number; // Candidate's application index
  }): Transaction {
    const tx = new Transaction();

    tx.moveCall({
      target: `${this.packageId}::minihub::hire_candidate`,
      arguments: [
        tx.object(params.jobId), // job: &mut Job
        tx.object(params.employerCapId), // employer_cap: &EmployerCap
        tx.pure.address(params.candidateAddress), // candidate_address: address
        tx.pure.u64(params.candidateIndex), // candidate_index: u64
      ],
    });

    return tx;
  }

  // ============================================================
  // DYNAMIC OBJECT FIELD QUERIES
  // ============================================================

  /**
   * Belirli bir başvuruyu dynamic field'dan oku
   * Read a specific application from dynamic field
   * 
   * Not: Dynamic object field'ları doğrudan okumak için Sui RPC'ye özel query gerekir
   * Bu fonksiyon child object'leri bulmaya çalışır
   */
  async getApplication(params: {
    jobId: string;
    candidateAddress: string;
    index: number;
  }): Promise<ApplicationData | null> {
    try {
      // Dynamic object field'ları almak için getDynamicFields kullan
      const dynamicFields = await this.client.getDynamicFields({
        parentId: params.jobId,
      });

      // İlgili application'ı bul
      // ApplicationKey { candidate: address, index: u64 }
      for (const field of dynamicFields.data) {
        if (field.objectType.includes('ApplicationProfile')) {
          const objectData = await this.client.getObject({
            id: field.objectId,
            options: { showContent: true },
          });

          if (objectData.data?.content?.dataType === 'moveObject') {
            const fields = (objectData.data.content as any).fields;
            
            // Candidate ve index eşleşirse döndür
            if (
              fields.candidate === params.candidateAddress &&
              parseInt(fields.index || '0') === params.index
            ) {
              return {
                id: field.objectId,
                candidate: fields.candidate,
                jobId: fields.job_id,
                coverMessage: fields.cover_message,
                timestamp: fields.timestamp,
                cvUrl: fields.cv_url,
              };
            }
          }
        }
      }

      return null;
    } catch (error) {
      console.error('Error getting application:', error);
      return null;
    }
  }

  /**
   * Bir işin tüm başvurularını getir
   * Get all applications for a job
   */
  async getAllApplications(jobId: string): Promise<ApplicationData[]> {
    try {
      const dynamicFields = await this.client.getDynamicFields({
        parentId: jobId,
      });

      const applications: ApplicationData[] = [];

      for (const field of dynamicFields.data) {
        if (field.objectType.includes('ApplicationProfile')) {
          const objectData = await this.client.getObject({
            id: field.objectId,
            options: { showContent: true },
          });

          if (objectData.data?.content?.dataType === 'moveObject') {
            const fields = (objectData.data.content as any).fields;
            applications.push({
              id: field.objectId,
              candidate: fields.candidate,
              jobId: fields.job_id,
              coverMessage: fields.cover_message,
              timestamp: fields.timestamp,
              cvUrl: fields.cv_url,
            });
          }
        }
      }

      // Timestamp'e göre sırala (eskiden yeniye)
      return applications.sort((a, b) => parseInt(a.timestamp) - parseInt(b.timestamp));
    } catch (error) {
      console.error('Error getting all applications:', error);
      return [];
    }
  }

  /**
   * Belirli bir adayın tüm başvurularını getir (tüm işler için)
   * Get all applications by a specific candidate (across all jobs)
   */
  async getApplicationsByCandidate(candidateAddress: string): Promise<ApplicationData[]> {
    const allJobs = await this.getAllJobs();
    const applications: ApplicationData[] = [];

    for (const job of allJobs) {
      const jobApplications = await this.getAllApplications(job.id);
      const candidateApps = jobApplications.filter(
        (app) => app.candidate === candidateAddress
      );
      applications.push(...candidateApps);
    }

    return applications;
  }

  // ============================================================
  // UTILITY FUNCTIONS - Yardımcı Fonksiyonlar
  // ============================================================

  /**
   * Deadline'ı insan okunabilir formata çevir
   * Convert deadline to human readable format
   * @param deadlineMs - Deadline timestamp in milliseconds (as string)
   * @returns Formatted date string in Turkish locale
   */
  formatDeadline(deadlineMs: string): string {
    const date = new Date(parseInt(deadlineMs));
    return date.toLocaleDateString('tr-TR', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  }

  /**
   * Maaşı formatla
   * Format salary
   * @param salary - Salary amount as string or null
   * @returns Formatted salary string with currency
   */
  formatSalary(salary: string | null): string {
    if (!salary) return 'Belirtilmemiş';
    return new Intl.NumberFormat('tr-TR', {
      style: 'currency',
      currency: 'TRY',
    }).format(parseInt(salary));
  }

  /**
   * Deadline'ın geçip geçmediğini kontrol et
   * Check if deadline has passed
   * @param deadlineMs - Deadline timestamp in milliseconds (as string)
   * @returns True if deadline has passed, false otherwise
   */
  isDeadlinePassed(deadlineMs: string): boolean {
    return Date.now() > parseInt(deadlineMs);
  }

  /**
   * Deadline'a kalan süreyi hesapla
   * Calculate time remaining until deadline
   * @param deadlineMs - Deadline timestamp in milliseconds (as string)
   * @returns Human-readable time remaining string
   */
  getTimeUntilDeadline(deadlineMs: string): string {
    const now = Date.now();
    const deadline = parseInt(deadlineMs);
    const diff = deadline - now;

    if (diff <= 0) return 'Süresi dolmuş';

    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));

    if (days > 0) return `${days} gün ${hours} saat`;
    return `${hours} saat`;
  }

  /**
   * İlanın başvuruya açık olup olmadığını kontrol et
   * Check if job is open for applications
   * @param job - Job data object
   * @returns True if job is active and deadline hasn't passed
   */
  isJobOpenForApplications(job: JobData): boolean {
    return job.isActive && !this.isDeadlinePassed(job.deadline);
  }

  /**
   * İş ilanını kategorilere göre filtrele
   * Filter jobs by various criteria
   * @param jobs - Array of job data
   * @param filters - Filter criteria object
   * @returns Filtered job array
   */
  filterJobs(
    jobs: JobData[],
    filters: {
      isActive?: boolean;
      hasDeadlinePassed?: boolean;
      minSalary?: number;
      maxSalary?: number;
      employerAddress?: string;
    }
  ): JobData[] {
    return jobs.filter((job) => {
      // Aktiflik kontrolü
      if (filters.isActive !== undefined && job.isActive !== filters.isActive) {
        return false;
      }

      // Deadline kontrolü
      if (filters.hasDeadlinePassed !== undefined) {
        const isPassed = this.isDeadlinePassed(job.deadline);
        if (isPassed !== filters.hasDeadlinePassed) {
          return false;
        }
      }

      // Minimum maaş kontrolü
      if (filters.minSalary !== undefined && job.salary) {
        if (parseInt(job.salary) < filters.minSalary) {
          return false;
        }
      }

      // Maximum maaş kontrolü
      if (filters.maxSalary !== undefined && job.salary) {
        if (parseInt(job.salary) > filters.maxSalary) {
          return false;
        }
      }

      // İşveren adresi kontrolü
      if (filters.employerAddress && job.employer !== filters.employerAddress) {
        return false;
      }

      return true;
    });
  }

  /**
   * İş ilanlarını sırala
   * Sort jobs by various criteria
   * @param jobs - Array of job data
   * @param sortBy - Sort criterion
   * @param order - Sort order ('asc' or 'desc')
   * @returns Sorted job array
   */
  sortJobs(
    jobs: JobData[],
    sortBy: 'salary' | 'deadline' | 'applicationCount',
    order: 'asc' | 'desc' = 'desc'
  ): JobData[] {
    const sorted = [...jobs].sort((a, b) => {
      let compareValue = 0;

      switch (sortBy) {
        case 'salary':
          const salaryA = a.salary ? parseInt(a.salary) : 0;
          const salaryB = b.salary ? parseInt(b.salary) : 0;
          compareValue = salaryA - salaryB;
          break;

        case 'deadline':
          compareValue = parseInt(a.deadline) - parseInt(b.deadline);
          break;

        case 'applicationCount':
          compareValue = parseInt(a.applicationCount) - parseInt(b.applicationCount);
          break;
      }

      return order === 'asc' ? compareValue : -compareValue;
    });

    return sorted;
  }

  /**
   * İlandan bu yana geçen süreyi hesapla (başvuru zamanı için)
   * Calculate time elapsed since application
   * @param timestampMs - Application timestamp in milliseconds (as string)
   * @returns Human-readable elapsed time string
   */
  getTimeElapsed(timestampMs: string): string {
    const now = Date.now();
    const timestamp = parseInt(timestampMs);
    const diff = now - timestamp;

    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) return `${days} gün önce`;
    if (hours > 0) return `${hours} saat önce`;
    if (minutes > 0) return `${minutes} dakika önce`;
    return 'Az önce';
  }

  /**
   * Başvuru istatistiklerini hesapla
   * Calculate application statistics for a job
   * @param applications - Array of application data
   * @returns Statistics object
   */
  getApplicationStats(applications: ApplicationData[]): {
    total: number;
    byDay: { [date: string]: number };
    averagePerDay: number;
  } {
    const total = applications.length;
    const byDay: { [date: string]: number } = {};

    applications.forEach((app) => {
      const date = new Date(parseInt(app.timestamp)).toLocaleDateString('tr-TR');
      byDay[date] = (byDay[date] || 0) + 1;
    });

    const days = Object.keys(byDay).length;
    const averagePerDay = days > 0 ? total / days : 0;

    return { total, byDay, averagePerDay };
  }

  /**
   * Maaş aralığı belirle (istatistikler için)
   * Determine salary range for statistics
   * @param jobs - Array of job data
   * @returns Salary range object
   */
  getSalaryRange(jobs: JobData[]): {
    min: number;
    max: number;
    average: number;
    median: number;
  } {
    const salaries = jobs
      .filter((job) => job.salary !== null)
      .map((job) => parseInt(job.salary!))
      .sort((a, b) => a - b);

    if (salaries.length === 0) {
      return { min: 0, max: 0, average: 0, median: 0 };
    }

    const min = salaries[0];
    const max = salaries[salaries.length - 1];
    const average = salaries.reduce((sum, val) => sum + val, 0) / salaries.length;
    const median = salaries[Math.floor(salaries.length / 2)];

    return { min, max, average, median };
  }

  /**
   * İş ilanı arama (başlık ve açıklamada)
   * Search jobs by title and description
   * @param jobs - Array of job data
   * @param searchTerm - Search term
   * @returns Filtered job array matching search term
   */
  searchJobs(jobs: JobData[], searchTerm: string): JobData[] {
    const term = searchTerm.toLowerCase();
    return jobs.filter(
      (job) =>
        job.title.toLowerCase().includes(term) ||
        job.description.toLowerCase().includes(term)
    );
  }

  /**
   * Kullanıcının başvurabileceği ilanları filtrele
   * Filter jobs that user can apply to
   * @param jobs - Array of job data
   * @param userApplications - Array of user's application data
   * @returns Jobs that user hasn't applied to yet
   */
  getApplicableJobs(
    jobs: JobData[],
    userApplications: ApplicationData[]
  ): JobData[] {
    const appliedJobIds = new Set(userApplications.map((app) => app.jobId));
    return jobs.filter(
      (job) =>
        !appliedJobIds.has(job.id) &&
        this.isJobOpenForApplications(job)
    );
  }

  /**
   * İşveren için dashboard istatistikleri
   * Get dashboard statistics for employer
   * @param employerAddress - Employer address
   * @returns Statistics object with various metrics
   */
  async getEmployerDashboardStats(employerAddress: string): Promise<{
    totalJobs: number;
    activeJobs: number;
    totalApplications: number;
    hiredCandidates: number;
    jobsWithApplications: number;
  }> {
    const jobs = await this.getJobsByEmployer(employerAddress);
    const activeJobs = jobs.filter((job) => job.isActive).length;
    const hiredCandidates = jobs.filter((job) => job.hiredCandidate !== null).length;

    let totalApplications = 0;
    let jobsWithApplications = 0;

    for (const job of jobs) {
      const appCount = parseInt(job.applicationCount);
      totalApplications += appCount;
      if (appCount > 0) {
        jobsWithApplications++;
      }
    }

    return {
      totalJobs: jobs.length,
      activeJobs,
      totalApplications,
      hiredCandidates,
      jobsWithApplications,
    };
  }

  /**
   * Aday için dashboard istatistikleri
   * Get dashboard statistics for candidate
   * @param candidateAddress - Candidate address
   * @returns Statistics object with application metrics
   */
  async getCandidateDashboardStats(candidateAddress: string): Promise<{
    totalApplications: number;
    pendingApplications: number;
    acceptedApplications: number;
    rejectedApplications: number;
  }> {
    const applications = await this.getApplicationsByCandidate(candidateAddress);
    const totalApplications = applications.length;

    let pendingApplications = 0;
    let acceptedApplications = 0;
    let rejectedApplications = 0;

    for (const app of applications) {
      const job = await this.getJob(app.jobId);
      
      if (job.hiredCandidate === candidateAddress) {
        acceptedApplications++;
      } else if (job.hiredCandidate !== null || !job.isActive) {
        rejectedApplications++;
      } else {
        pendingApplications++;
      }
    }

    return {
      totalApplications,
      pendingApplications,
      acceptedApplications,
      rejectedApplications,
    };
  }

  /**
   * Deadline'ı güncelle (frontend için hesaplama)
   * Calculate deadline from now
   * @param days - Number of days from now
   * @returns Deadline timestamp in milliseconds
   */
  calculateDeadline(days: number): number {
    return Date.now() + days * 24 * 60 * 60 * 1000;
  }

  /**
   * CV URL validasyonu
   * Validate CV URL format
   * @param url - CV URL to validate
   * @returns True if URL is valid
   */
  isValidCvUrl(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Başvuru durum kontrolü
   * Check application status for a candidate
   * @param jobId - Job ID
   * @param candidateAddress - Candidate address
   * @returns Status object
   */
  async getApplicationStatus(
    jobId: string,
    candidateAddress: string
  ): Promise<{
    hasApplied: boolean;
    isHired: boolean;
    isRejected: boolean;
    isPending: boolean;
  }> {
    const job = await this.getJob(jobId);
    const applications = await this.getAllApplications(jobId);
    const hasApplied = applications.some((app) => app.candidate === candidateAddress);

    if (!hasApplied) {
      return {
        hasApplied: false,
        isHired: false,
        isRejected: false,
        isPending: false,
      };
    }

    const isHired = job.hiredCandidate === candidateAddress;
    const isRejected = job.hiredCandidate !== null && job.hiredCandidate !== candidateAddress;
    const isPending = !isHired && !isRejected && job.isActive;

    return { hasApplied, isHired, isRejected, isPending };
  }

  /**
   * Popüler ilanları getir (en çok başvurulanlar)
   * Get popular jobs (most applications)
   * @param limit - Number of jobs to return
   * @returns Top jobs by application count
   */
  async getPopularJobs(limit: number = 10): Promise<JobData[]> {
    const allJobs = await this.getAllJobs();
    return this.sortJobs(allJobs, 'applicationCount', 'desc').slice(0, limit);
  }

  /**
   * Yeni eklenen ilanları getir
   * Get recently posted jobs
   * @param limit - Number of jobs to return
   * @returns Recently posted jobs (deadline'a göre sıralı)
   */
  async getRecentJobs(limit: number = 10): Promise<JobData[]> {
    const allJobs = await this.getAllJobs();
    // Deadline'a göre sırala (en yeni olanlar en büyük deadline'a sahip olur)
    return this.sortJobs(allJobs, 'deadline', 'desc').slice(0, limit);
  }

  // ============================================================
  // EVENT LISTENERS - Olay Dinleyiciler
  // ============================================================

  /**
   * JobPosted olaylarını dinle
   * Subscribe to JobPosted events
   * @param callback - Callback function to handle event data
   * @returns Unsubscribe function
   */
  async subscribeToJobPosted(
    callback: (event: any) => void
  ): Promise<() => void> {
    const unsubscribe = await this.client.subscribeEvent({
      filter: {
        MoveEventType: `${this.packageId}::minihub::JobPosted`,
      },
      onMessage: (event: any) => {
        callback(event.parsedJson);
      },
    });

    return unsubscribe;
  }

  /**
   * ApplicationSubmitted olaylarını dinle
   * Subscribe to ApplicationSubmitted events
   * @param callback - Callback function to handle event data
   * @returns Unsubscribe function
   */
  async subscribeToApplicationSubmitted(
    callback: (event: any) => void
  ): Promise<() => void> {
    const unsubscribe = await this.client.subscribeEvent({
      filter: {
        MoveEventType: `${this.packageId}::minihub::ApplicationSubmitted`,
      },
      onMessage: (event: any) => {
        callback(event.parsedJson);
      },
    });

    return unsubscribe;
  }

  /**
   * CandidateHired olaylarını dinle
   * Subscribe to CandidateHired events
   * @param callback - Callback function to handle event data
   * @returns Unsubscribe function
   */
  async subscribeToCandidateHired(
    callback: (event: any) => void
  ): Promise<() => void> {
    const unsubscribe = await this.client.subscribeEvent({
      filter: {
        MoveEventType: `${this.packageId}::minihub::CandidateHired`,
      },
      onMessage: (event: any) => {
        callback(event.parsedJson);
      },
    });

    return unsubscribe;
  }
}

// ============================================================
// REACT HOOKS - React Hook'ları
// ============================================================

// Note: React import should be done in the consuming application
// React import'u kullanan uygulamada yapılmalıdır

/**
 * React Hook örneği - useJobs
 * Example React Hook - useJobs
 * 
 * @param sdk - MiniHubSDK instance
 * @returns Object with jobs data, loading state, error state, and refetch function
 * 
 * Usage in React component:
 * ```tsx
 * import { useJobs } from './sdk/minihub';
 * import React from 'react';
 * 
 * function JobList() {
 *   const { jobs, loading, error, refetch } = useJobs(sdk);
 *   
 *   if (loading) return <div>Loading...</div>;
 *   if (error) return <div>Error: {error.message}</div>;
 *   
 *   return (
 *     <div>
 *       {jobs.map(job => (
 *         <JobCard key={job.id} job={job} />
 *       ))}
 *       <button onClick={refetch}>Yenile</button>
 *     </div>
 *   );
 * }
 * ```
 */
export function useJobs(sdk: MiniHubSDK): {
  jobs: JobData[];
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
} {
  // React hooks should be imported from 'react' in the consuming app
  // This is a type-only declaration for documentation purposes
  throw new Error(
    'useJobs hook requires React to be installed. Import React in your application and use this pattern.'
  );
}

/**
 * React Hook - useJob (tek bir iş ilanı için)
 * Hook to fetch a single job
 * 
 * @param sdk - MiniHubSDK instance
 * @param jobId - Job ID to fetch
 * @returns Object with job data, loading state, error state, and refetch function
 */
export function useJob(sdk: MiniHubSDK, jobId: string): {
  job: JobData | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
} {
  throw new Error('useJob hook requires React. See documentation for usage pattern.');
}

/**
 * React Hook - useApplications (bir ilanın başvurularını getir)
 * Hook to fetch applications for a job
 * 
 * @param sdk - MiniHubSDK instance
 * @param jobId - Job ID to fetch applications for
 * @returns Object with applications data, loading state, error state, and refetch function
 */
export function useApplications(sdk: MiniHubSDK, jobId: string): {
  applications: ApplicationData[];
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
} {
  throw new Error('useApplications hook requires React. See documentation for usage pattern.');
}

/**
 * React Hook - useEmployerDashboard (işveren dashboard verileri)
 * Hook to fetch employer dashboard statistics
 * 
 * @param sdk - MiniHubSDK instance
 * @param employerAddress - Employer address
 * @returns Object with dashboard stats, loading state, error state, and refetch function
 */
export function useEmployerDashboard(sdk: MiniHubSDK, employerAddress: string): {
  stats: {
    totalJobs: number;
    activeJobs: number;
    totalApplications: number;
    hiredCandidates: number;
    jobsWithApplications: number;
  } | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
} {
  throw new Error('useEmployerDashboard hook requires React. See documentation for usage pattern.');
}

/**
 * React Hook - useCandidateDashboard (aday dashboard verileri)
 * Hook to fetch candidate dashboard statistics
 * 
 * @param sdk - MiniHubSDK instance
 * @param candidateAddress - Candidate address
 * @returns Object with dashboard stats, loading state, error state, and refetch function
 */
export function useCandidateDashboard(sdk: MiniHubSDK, candidateAddress: string): {
  stats: {
    totalApplications: number;
    pendingApplications: number;
    acceptedApplications: number;
    rejectedApplications: number;
  } | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
} {
  throw new Error('useCandidateDashboard hook requires React. See documentation for usage pattern.');
}

export default MiniHubSDK;
